
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Josh Tenenbaum's Number Game</title><meta name="generator" content="MATLAB 7.12"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2012-03-27"><meta name="DC.source" content="numbersGame.m"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head><body><div class="content"><h1>Josh Tenenbaum's Number Game</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#4">Hypothesis Spaces</a></li><li><a href="#5">A small hypothesis space</a></li><li><a href="#6">Tenenbaum's original hypothesis space with 34 mathematical and 5050 interval</a></li><li><a href="#7">Priors</a></li><li><a href="#8">Likelihoods</a></li><li><a href="#9">Posteriors</a></li><li><a href="#10">Predictive</a></li><li><a href="#11">Helper Functions</a></li><li><a href="#12">Display Functions</a></li><li><a href="#13">Hypothesis Building Functions</a></li></ul></div><pre class="codeinput"><span class="comment">% This file is from pmtk3.googlecode.com</span>

<span class="keyword">function</span> numbersGame
</pre><pre class="codeinput">first = 1; last = 100; <span class="comment">%Range for the hypothesis space</span>
hypFn        =  @mathHypothesesSmall;
priorFn      =  @mathPriorSmall;
likelihoodFn =  @likelihood;
posteriorFn  =  @posterior;
postPredFn   =  @postPredictive;
priorPredFn  =  @priorPredictive;

hypSpace = hypFn();
inconcept = buildExtensionTable(hypSpace);
</pre><pre class="codeinput">makePlots();
<span class="comment">% Note, plots won't work if using log likelihood or a large hypothesis</span>
<span class="comment">% space such as tenenbaumHypSpace. Be sure to comment this line out before</span>
<span class="comment">% trying these.</span>
</pre><img vspace="5" hspace="5" src="numbersGame_01.png" alt=""> <img vspace="5" hspace="5" src="numbersGame_02.png" alt=""> <img vspace="5" hspace="5" src="numbersGame_03.png" alt=""> <h2>Hypothesis Spaces<a name="4"></a></h2><h2>A small hypothesis space<a name="5"></a></h2><pre class="codeinput"><span class="keyword">function</span> hypSpace = mathHypothesesSmall()
    hypSpace = [ evenOdd()
                 predicateBased( @(x)(x == round(sqrt(x)).^2),<span class="string">'squares'</span>)
                 multiples(3:10)
                 endingIn(1:9)
                 powers(2:10)
                 predicateBased(@(x)(x==x),<span class="string">'all'</span>)
                 compose(powers(2),explicitSet([37]),@union,<span class="string">' +'</span>)
                 compose(powers(2),explicitSet([32]),@setdiff,<span class="string">' -'</span>)
               ];
    fields = {<span class="string">'extension'</span>,<span class="string">'name'</span>,<span class="string">'size'</span>};
    hypSpace = cell2struct(hypSpace,fields,2);
<span class="keyword">end</span>
</pre><h2>Tenenbaum's original hypothesis space with 34 mathematical and 5050 interval<a name="6"></a></h2><pre class="codeinput"><span class="keyword">function</span> hypSpace = tenenbaumHypSpace()
    hypSpace = [    evenOdd()
                    predicateBased( @(x)(x == round(sqrt(x)).^2),<span class="string">'squares'</span>)
                    predicateBased( @(x)(x == round(x.^(1/3)).^3),<span class="string">'cubes'</span>)
                    predicateBased( @(x)(isprime(x)),<span class="string">'primes'</span>)
                    multiples(3:12)
                    powers(2:10)
                    endingIn(0:9)
                    allContiguousIntervals()
               ];

    fields = {<span class="string">'extension'</span>,<span class="string">'name'</span>,<span class="string">'size'</span>};
    hypSpace = cell2struct(hypSpace,fields,2);

<span class="keyword">end</span>
</pre><h2>Priors<a name="7"></a></h2><pre class="codeinput"><span class="comment">% Prior on mathHypothesesSmall hypSpace, (a row vector)</span>
<span class="keyword">function</span> prior = mathPriorSmall(hypSpace)
    prior = [0.5 0.5 0.1*ones(1,28) 0.001 0.001];
    <span class="comment">%{odd,even} = 0.5 ; {powers of 2 + 37,powers of 2 - 32} = 0.001; else=0.1</span>
    assert(length(prior) == size(hypSpace,1));
    prior = prior ./ sum(prior);
<span class="keyword">end</span>

<span class="comment">% Prior on tenenbaumHypSpace() Math hyps are weigthed 2/3 to 1/3 against</span>
<span class="comment">% interval hyps. Gamma(2,10) prior applied to interval length hyps.</span>
<span class="keyword">function</span> prior = tenenbaumPrior(hypSpace)
     lambda = 2/3;
     math = (2/3)*ones(1,34);
     sizes = [hypSpace.size];
     sizes = sizes(35:end);
     ints = exp(gammalogprob(struct(<span class="string">'a'</span>, 2, <span class="string">'b'</span>, 10), sizes));
     ints = (1/3)*ints;
     prior = [math ints];
     prior = prior ./ sum(prior);
<span class="keyword">end</span>
</pre><h2>Likelihoods<a name="8"></a></h2><pre class="codeinput"><span class="comment">% Likelihood using the size principle: p(D|h)</span>
<span class="comment">% Returns row vector L, s.t. L(h) = p(D|h)</span>
<span class="keyword">function</span> L = likelihood(D,hypSpace)
    hypSpaceSize = size(hypSpace,1);
    n = length(D);
    lik = zeros(n,hypSpaceSize);
    <span class="keyword">for</span> i=1:n
        lik(i,:) = inconcept(D(i),:) ./ [hypSpace.size];
    <span class="keyword">end</span>
    L = prod(lik,1);
<span class="keyword">end</span>

<span class="comment">% Log Likelihood using size principle, log(p(D|h))</span>
<span class="comment">% Use to avoid numerical underflow.</span>
<span class="keyword">function</span> LL = logLikelihood(D,hypSpace)
    hypSpaceSize = size(hypSpace,1);
    n = length(D);
    llik = zeros(n,hypSpaceSize);
    <span class="keyword">for</span> i=1:n
        <span class="comment">%log(0) -&gt; log(eps) to prevent NaN; note exp(log(eps)) = eps approx 0</span>
        llik(i,:) = log((inconcept(D(i),:) ./ [hypSpace.size])+ eps);
    <span class="keyword">end</span>
    LL = sum(llik,1);
<span class="keyword">end</span>
</pre><h2>Posteriors<a name="9"></a></h2><pre class="codeinput"><span class="comment">% Posterior Distribution, p(h|D)</span>
<span class="keyword">function</span> post = posterior(D,hypSpace)
    post = priorFn(hypSpace) .* likelihoodFn(D,hypSpace);
    post = post / sum(post);
<span class="keyword">end</span>

<span class="comment">% Posterior Distribution p(h|D) - uses log likelihood instead of just</span>
<span class="comment">% likelihood to help avoid numerical underflow. Returns p(h|D) not</span>
<span class="comment">% log(p(h|D)) but likelihoodFn needs to return log likelihood, not</span>
<span class="comment">% likelihood.</span>
<span class="keyword">function</span> post = posteriorLL(D,hypSpace)
    logLik = likelihoodFn(D,hypSpace);
    logPrior = log(priorFn(hypSpace));
    logNumerator = logLik + logPrior;
    post = exp(logNumerator);
    post = post / sum(post);
<span class="keyword">end</span>
</pre><h2>Predictive<a name="10"></a></h2><pre class="codeinput"><span class="comment">% Posterior predictive distribution, p(x|D)</span>
<span class="keyword">function</span> pred = postPredictive(post)
    pred = inconcept * post(:); <span class="comment">% pred(x) = sum_h inconcept(x,h) post(h)</span>
<span class="keyword">end</span>

<span class="comment">% Prior Predictive Distribution:</span>
<span class="comment">% pred(i) is the prior predictive probability that integer i is in C</span>
<span class="keyword">function</span> pred = priorPredictive(hypSpace)
    prior = priorFn(hypSpace);
    cl = zeros(size(inconcept));
    <span class="keyword">for</span> col=1:size(hypSpace,1)
        ext = hypSpace(col).extension;
        cl(ext,col) = inconcept(ext,col)./hypSpace(col).size;
    <span class="keyword">end</span>
    <span class="comment">% cl(x,h) = p(x|h) is the likelihood assigned to integer x by</span>
    <span class="comment">% hypothesis h by the size principle, (before any data has been seen).</span>
    pred = cl(first:last,:)*prior';
<span class="keyword">end</span>
</pre><h2>Helper Functions<a name="11"></a></h2><pre class="codeinput"><span class="comment">% Builds a binary table whose rows represent the possible data points in the</span>
<span class="comment">% range, (i.e. 1 - 100) - shifted so that the first is represented by index</span>
<span class="comment">% 1.The columns represent hypotheses, (i.e.indices into the hypSpace struct).</span>
<span class="comment">% Entry (d,h) = 1 iff data point d occurs in the extension of hypothesis h.</span>
<span class="keyword">function</span> inconcept = buildExtensionTable(hypSpace)
    hypSpaceSize = size(hypSpace,1);
    inconcept = zeros(last-first+1,hypSpaceSize);
    <span class="keyword">for</span> h=1:hypSpaceSize
        hyp = hypSpace(h).extension;
        inconcept(hyp,h) = 1;
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2>Display Functions<a name="12"></a></h2><pre class="codeinput"><span class="comment">% Make a number of plots of the hypothesis space, prior,</span>
<span class="comment">% likelihood,posterior,and posterior predictive distributions.</span>
<span class="comment">% Needs hypSpace and inconcept as global variables.</span>
<span class="keyword">function</span> makePlots()
    close <span class="string">all</span>;
    data = [16,8,2,64];
    <span class="comment">%data = [16, 23, 19, 20];</span>
    <span class="comment">%displayHypothesisSpace(inconcept,hypSpace);</span>
    printPmtkFigure(<span class="string">'joshHypSpace'</span>);


    plotPriorLikPost(16, hypSpace, priorFn, likelihoodFn,posteriorFn);
    printPmtkFigure(<span class="string">'joshPriorLikPost16'</span>);


    plotPriorLikPost(data, hypSpace, priorFn, likelihoodFn,posteriorFn);
    printPmtkFigure(<span class="string">'joshPriorLikPostAll'</span>);

<span class="comment">    %{
</span><span class="comment">    plotDistribution(data,hypSpace,likelihoodFn,1);
</span><span class="comment">    printPmtkFigure('numbersLik');
</span><span class="comment">
</span><span class="comment">    plotDistribution(data,hypSpace,posteriorFn,0);
</span><span class="comment">    printPmtkFigure('numbersPost');
</span><span class="comment">
</span><span class="comment">    plotPrior(hypSpace);
</span><span class="comment">    printPmtkFigure('numbersPrior');
</span><span class="comment">   %}
</span>
    visualizePredictive(inconcept,[16],hypSpace);
    <span class="comment">%printPmtkFigure('josh-2-9');</span>
    printPmtkFigure(<span class="string">'joshPredictive16'</span>);

    <span class="comment">%visualizePredictive(inconcept,data,hypSpace);</span>
    <span class="comment">%plotGamma();</span>
<span class="keyword">end</span>

<span class="comment">% Display the top, 'howMany' hypotheses as determined by the specified</span>
<span class="comment">% posterior.</span>
<span class="keyword">function</span> displayBestHyps(howMany,post)
    [H, idx] = sort(post,<span class="string">'descend'</span>);
    names = {hypSpace.name};
    fprintf(<span class="string">'Top Posterior Hypotheses'</span>);
    fprintf(<span class="string">'\n%1s %9s\n\n'</span>,<span class="string">'Probability'</span>,<span class="string">'Name'</span>);
    <span class="keyword">for</span> i=1:1:howMany
        names = {hypSpace.name};
        fprintf(<span class="string">'%1s\t\t\t %1s\n'</span>,num2str(H(i),<span class="string">'%6.5f'</span>),cell2mat(names(idx(i))));
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% Visualize the hypothesis space.</span>
<span class="keyword">function</span> displayHypothesisSpace(inconcept,hypSpace)
    fig = figure;
    ax = axes(<span class="string">'Parent'</span>,fig,<span class="string">'XTick'</span>,1:size(hypSpace,1),<span class="string">'Position'</span>,[0.1,0.25,0.8,0.70]);
    axis([1,size(hypSpace,1),first-1,last+1]);
    hold <span class="string">on</span>;
    imagesc(inconcept,<span class="string">'Parent'</span>,ax);
    colormap(gray);
    xticklabelRot({hypSpace.name}, 90, 8,-1);
    title(<span class="string">'hypothesis space'</span>)
<span class="keyword">end</span>


<span class="comment">% Plot a labeled horizontal histogram of the current prior.</span>
<span class="keyword">function</span> plotPrior(hypSpace)
    H = size(hypSpace,1);
    prior = priorFn(hypSpace);
    prior = prior(end:-1:1);
    names = {hypSpace.name};
    names = names(end:-1:1);
    fig = figure(<span class="string">'Color'</span>,[1 1 1],<span class="string">'Position'</span>,[500 100 300,600]);
    axes(<span class="string">'Parent'</span>,fig,<span class="string">'YTickLabel'</span>,names,<span class="string">'YTick'</span>,1:H,<span class="string">'Position'</span>,[0.4 0.12 0.50 0.8]);
    hold <span class="string">on</span>;
    barh(prior);
    axis([0 1 0 H+1]);
    set(gca,<span class="string">'XTick'</span>,[0,0.5,1]);
    xlabel(<span class="string">'p(h)'</span>);
<span class="keyword">end</span>

<span class="comment">%Plot either the likelihood or posterior distributions as histograms for</span>
<span class="comment">%successive data points. pdf should be likelihoodFn or posteriorFn and</span>
<span class="comment">%isLik=1 to print likelihood xlabel isLik=0 for posterior xlabel.</span>
<span class="keyword">function</span> plotDistribution(data,hypSpace,pdf,isLik)
   H = size(hypSpace,1);
   scrsz = get(0,<span class="string">'ScreenSize'</span>);
   fig = figure(<span class="string">'Color'</span>,[1 1 1],<span class="string">'Position'</span>,[20 50 5*scrsz(3)/10 8*scrsz(4)/10]);
   n = length(data);
   height = 0.8; buffer = 0.03; y = 0.12; extraGap = 0.1;
   border = 0.1; width = (1-2*border - extraGap - buffer*(n-1))/n;
   <span class="keyword">for</span> i=1:length(data)
       <span class="keyword">if</span>(i==1)
           names = {hypSpace.name}; names = names(end:-1:1);
           ax = axes(<span class="string">'Parent'</span>,fig,<span class="string">'YTickLabel'</span>,names,<span class="string">'YTick'</span>,1:H,<span class="string">'Position'</span>,[border+extraGap,y,width,height]);
       <span class="keyword">else</span>
           ax = axes(<span class="string">'Parent'</span>,fig,<span class="string">'YTick'</span>,[],<span class="string">'Position'</span>,[border+extraGap+(i-1)*(width+buffer),y,width,height]);
       <span class="keyword">end</span>
      hold <span class="string">on</span>;
       lik = pdf(data(1:i),hypSpace);
       lik = lik(end:-1:1);
       barh(lik,<span class="string">'Parent'</span>,ax);
       <span class="keyword">if</span>(isLik)
           xlabel([<span class="string">'p('</span> num2str(data(1:i)) <span class="string">' | h)'</span>]);
       <span class="keyword">else</span>
           xlabel([<span class="string">'p(h | '</span> num2str(data(1:i)) <span class="string">' )'</span>]);
       <span class="keyword">end</span>
   <span class="keyword">end</span>
<span class="keyword">end</span>

  <span class="keyword">function</span> plotPriorLikPost(data, hypSpace, priorFn, likFn, postFn)
    H = size(hypSpace,1);
     prior = priorFn(hypSpace);
    prior = prior(end:-1:1);

    scrsz = get(0,<span class="string">'ScreenSize'</span>);
    fig = figure(<span class="string">'Color'</span>,[1 1 1],<span class="string">'Position'</span>,[20 50 5*scrsz(3)/10 8*scrsz(4)/10]);
    n = 3;
    height = 0.8; buffer = 0.03; y = 0.12; extraGap = 0.1;
    border = 0.1; width = (1-2*border - extraGap - buffer*(n-1))/n;

    names = {hypSpace.name}; names = names(end:-1:1);
    ax = axes(<span class="string">'Parent'</span>,fig,<span class="string">'YTickLabel'</span>,names,<span class="string">'YTick'</span>,1:H,<span class="string">'Position'</span>,[border+extraGap,y,width,height]);
    hold <span class="string">on</span>;
    <span class="comment">%barh(prior);</span>
    barh(prior, <span class="string">'Parent'</span>, ax);
    <span class="comment">%axis([0 1 0 H+1]);</span>
    <span class="comment">%set(gca,'XTick',[0,0.5,1]);</span>
    xlabel(<span class="string">'prior'</span>);

    i = 2; ax =  axes(<span class="string">'Parent'</span>,fig,<span class="string">'YTickLabel'</span>,names,<span class="string">'YTick'</span>,1:H,<span class="string">'Position'</span>,[border+extraGap+(i-1)*(width+buffer),y,width,height]);
    lik = likFn(data,hypSpace);
    lik = lik(end:-1:1);
    barh(lik,<span class="string">'Parent'</span>,ax);
    xlabel(<span class="string">'lik'</span>);
     title(sprintf(<span class="string">'data = %s'</span>, num2str(data)))

    i = 3; ax =  axes(<span class="string">'Parent'</span>,fig,<span class="string">'YTick'</span>,1:H,<span class="string">'YtickLabel'</span>,{},<span class="string">'Position'</span>,[border+extraGap+(i-1)*(width+buffer),y,width,height]);
    post = postFn(data,hypSpace);
    post = post(end:-1:1);
    barh(post,<span class="string">'Parent'</span>,ax);
    xlabel(<span class="string">'post'</span>);



  <span class="keyword">end</span>



<span class="comment">% Visualize the posterior predictive distribution</span>
<span class="keyword">function</span> visualizePredictive(inconcept,data,hypSpace)

    post = posteriorFn(data,hypSpace);
    pred = postPredFn(post);
    scrsz = get(0,<span class="string">'ScreenSize'</span>);
    fig = figure(<span class="string">'Color'</span>,[1 1 1],<span class="string">'Position'</span>,[20 50 9*scrsz(3)/10 8*scrsz(4)/10]);
    plotBar;
    probs = plotHyps;
    plotPost;
    <span class="keyword">function</span> plotBar
        barAxLoc = [0.1,0.7,0.7,0.25];
        barAx = axes(<span class="string">'Parent'</span>,fig,<span class="string">'XTick'</span>,first-1+4:4:last,<span class="string">'YTick'</span>,0:0.5:1,<span class="string">'Position'</span>,barAxLoc);
        hold <span class="string">on</span>;
        bar(pred,<span class="string">'Parent'</span>,barAx);
        axis([first-1,last+1,0,1]);
    <span class="keyword">end</span>
    <span class="keyword">function</span> probs = plotHyps
        consistentHyps = 1:size(hypSpace,1);
        <span class="keyword">for</span> i=1:length(data)
            consistentHyps = intersect(consistentHyps,find(inconcept(data(i),:) == 1));
        <span class="keyword">end</span>
        names = {hypSpace.name};
        names = names(consistentHyps);
        [probs ndx] = sort(post(consistentHyps));
        names = names(ndx);
        consistentHyps = consistentHyps(ndx);
        hypAxLoc = [0.1,0.08,0.7,0.57];
        hypAx = axes(<span class="string">'Parent'</span>,fig,<span class="string">'XTick'</span>,[],<span class="string">'YTick'</span>,1:length(names),<span class="string">'XColor'</span>,[1 1 1],<span class="string">'YTickLabel'</span>,names,<span class="string">'Position'</span>,hypAxLoc);
        hold <span class="string">on</span>;
        <span class="keyword">for</span> i=1:length(names)
            h = consistentHyps(i);
            hyp = hypSpace(h).extension;
            fplot(@(x)i,[first-1,last+1,1,length(names)+ 0.02],<span class="string">'-k'</span>);
            hold <span class="string">on</span>;
            y = i*ones(length(hyp));
            plot(hyp,y,<span class="string">'.b'</span>,<span class="string">'MarkerSize'</span>,20);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">function</span> plotPost
        postAxLoc = [0.83,0.08,0.13,0.57];
        postAx = axes(<span class="string">'Parent'</span>,fig,<span class="string">'XTick'</span>,0:0.5:1,<span class="string">'YTick'</span>,[],<span class="string">'Position'</span>,postAxLoc);
        xlabel([<span class="string">'p(h | '</span> num2str(data) <span class="string">' )'</span>]);
        hold <span class="string">on</span>;
        plot(probs,1:length(probs),<span class="string">'-o'</span>,<span class="string">'linewidth'</span>,3);
        axis([0,1,1,length(probs)]);
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2>Hypothesis Building Functions<a name="13"></a></h2><pre class="codeinput">    <span class="comment">%Returns two hypotheses: all even numbers in the range and all odd</span>
    <span class="comment">%numbers in the range.</span>
    <span class="keyword">function</span> hypotheses = evenOdd()
       even = first+1:2:last;
       odd = first:2:last;
       hyps = [{even};{odd}];
       names = [{<span class="string">'even'</span>};{<span class="string">'odd'</span>}];
       sizes = [ {size(even,2)} ; {size(odd,2)}];
       hypotheses = [hyps names sizes];
    <span class="keyword">end</span>


    <span class="comment">% If range = 1:100 and ints = [3,9,10], then hypotheses =</span>
    <span class="comment">% [3,6,9,...,99]; [9,18,27,...,99];[10,20,30,...,100]</span>
    <span class="keyword">function</span> hypotheses = multiples(ints)
        n = length(ints);
        hyps = cell(n,1);
        names = cell(n,1);
        sizes = cell(n,1);
        <span class="keyword">for</span> i=1:n
            m = ints(i);
            xmax = ceil(last/m);
            hyps{i,1} = intersect(first:last, m*(first:xmax));
            names{i,1} = sprintf(<span class="string">'mult of %d'</span>, m);
            sizes{i,1} = size(hyps{i,1},2);
        <span class="keyword">end</span>
        hypotheses = [hyps names sizes];
    <span class="keyword">end</span>

    <span class="comment">% If range = 1:100 and ints = 1:3, then hypotheses = [1,11,21,...,91];</span>
    <span class="comment">% [2,22,32,...,92];[3,23,33,...,93]</span>
    <span class="keyword">function</span> hypotheses = endingIn(ints)
        fst = first - 1;
        lst = last - 10;
        n = length(ints);
        hyps =  cell(n,1);
        names = cell(n,1);
        sizes = cell(n,1);
        <span class="keyword">for</span> i=1:n
            m = ints(i);
            <span class="keyword">if</span> m==0
                hyps{i,1} = (fst+10:10:lst+10) + m;
            <span class="keyword">else</span>
                hyps{i,1} = (fst:10:lst) + m;
            <span class="keyword">end</span>
            names{i,1} =  sprintf(<span class="string">'ends in %d'</span>, m);
            sizes{i,1} = size(hyps{i,1},2);
        <span class="keyword">end</span>
        hypotheses = [hyps names sizes];
    <span class="keyword">end</span>

    <span class="comment">%If range = 1:100 and pows = 4:7, hypotheses = [4 16 64] ; [5 25];</span>
    <span class="comment">%[6:36]; [7;49]</span>
    <span class="keyword">function</span> hypotheses = powers(pows)
        n = length(pows);
        hyps = cell(n,1);
        names = cell(n,1);
        sizes = cell(n,1);
        <span class="keyword">for</span> i=1:n;
            m = pows(i);
            xmax = ceil(log(last)/log(m));
            hyps{i,1} = intersect(first:last, m.^(first:xmax));
            names{i,1} = sprintf(<span class="string">'powers of %d'</span>, m);
            sizes{i,1} = size(hyps{i,1},2);
        <span class="keyword">end</span>
        hypotheses = [hyps names,sizes];
    <span class="keyword">end</span>

    <span class="comment">%Define an hypothesis by explicitly listing its members</span>
    <span class="keyword">function</span> hypothesis = explicitSet(set)
        hypothesis = [{set} {[<span class="string">' {'</span> num2str(set) <span class="string">'}'</span>]} {size(set,2)}];
    <span class="keyword">end</span>

    <span class="comment">% Compose two hypothesis sets row-wise according to the specified set</span>
    <span class="comment">% operator, (i.e. @union, @setdiff, etc). If we specified @union,</span>
    <span class="comment">% and had hyp1(:,1) = {[1 2 3] ; [4 5 6]} and hyp2(:,1) = {[3 9 27];[4 44 444]}</span>
    <span class="comment">% this function would return hypotheses(:,1) =  {[1 2 3 9 27] ;</span>
    <span class="comment">% [4 5 6 44 444]}. 'str' is displayed in the hypothesis name so use '+' for</span>
    <span class="comment">% 'union', '-' for setdiff, etc.</span>
    <span class="keyword">function</span> hypotheses = compose(hyp1,hyp2,operator,str)
        n = size(hyp1,1);
        hyps = cell(n,1);
        names = cell(n,1);
        sizes = cell(n,1);
        <span class="keyword">for</span> i=1:n
            hyps{i,1} = operator(cell2mat(hyp1(i,1))',cell2mat(hyp2(i,1))',<span class="string">'rows'</span>)';
            names{i,1} = strcat(hyp1{i,2}, str, hyp2{i,2});
            sizes{i,1} = size(hyps{i,1},2);
        <span class="keyword">end</span>
        hypotheses = [hyps names sizes];
    <span class="keyword">end</span>


    <span class="comment">% Hypothesis = all numbers in the range satisfying the specified</span>
    <span class="comment">% predicate. So for example, if predicate = @isprime, then the hypothesis is</span>
    <span class="comment">% all prime numbers in the range. You can also define your own</span>
    <span class="comment">% predicates say  @(x)(x&gt;50) or @(x)(x==x)</span>
    <span class="keyword">function</span> hypothesis = predicateBased(predicate,name)
        range = first:last;
        logicalNDX = predicate(range);
        size = sum(logicalNDX);
        hyp = range(logicalNDX);
        hypothesis = [{hyp} {name} {size}];
    <span class="keyword">end</span>

    <span class="comment">%Hypotheses = all contiguous intervals in the range so [1],</span>
    <span class="comment">%[1,2],...,[1,...,100],[2],[2,3],...,[2,...,100],... etc.</span>
    <span class="keyword">function</span> hypotheses = allContiguousIntervals()
        i = 1;
        n = last*(last+1)/2;
        hyps = cell(n,1);
        names = cell(n,1);
        sizes = cell(n,1);
        <span class="keyword">for</span> s = first:last
            <span class="keyword">for</span> e=s:last
                hyps{i,1} = s:e;
                names{i,1} = sprintf(<span class="string">'interval %d..%d'</span>, s, e);
                sizes{i,1} = size(hyps{i,1},2);
                i = i+1;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        hypotheses = [hyps names sizes];
    <span class="keyword">end</span>

    <span class="comment">%Hypotheses = all contiguous intervals in the range of the specified</span>
    <span class="comment">%lengths. Suppose lengths = 3:4, then we have</span>
    <span class="comment">%[1,2,3],[1,2,3,4],[2,3,4],[2,3,4,5],...,[97,98,99,100],[98,99,100]</span>
    <span class="keyword">function</span> hypotheses = contiguousIntervalsOflength(lengths)
        i = 1;
        n = sum(last - lengths + 1);
        hyps = cell(n,1);
        names = cell(n,1);
        sizes = cell(n,1);
        <span class="keyword">for</span> len=1:length(lengths)
           <span class="keyword">for</span> n=first:last
              m = n+len-1;
              <span class="keyword">if</span>(m&gt;last)
                  <span class="keyword">break</span>
              <span class="keyword">end</span>
              hyps{i,1} = n:m;
              names{i,1} = sprintf(<span class="string">'interval %d..%d'</span>, n, m);
              sizes{i,1} = size(hyps{i,1},2);
              i = i+1;
           <span class="keyword">end</span>
        <span class="keyword">end</span>
        hypotheses = [hyps names sizes];
    <span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.12<br></p></div><!--
##### SOURCE BEGIN #####
%% Josh Tenenbaum's Number Game
%
%%

% This file is from pmtk3.googlecode.com

function numbersGame
%% 
first = 1; last = 100; %Range for the hypothesis space
hypFn        =  @mathHypothesesSmall;
priorFn      =  @mathPriorSmall;            
likelihoodFn =  @likelihood;
posteriorFn  =  @posterior;     
postPredFn   =  @postPredictive;
priorPredFn  =  @priorPredictive;

hypSpace = hypFn();                         
inconcept = buildExtensionTable(hypSpace); 
%%
makePlots(); 
% Note, plots won't work if using log likelihood or a large hypothesis
% space such as tenenbaumHypSpace. Be sure to comment this line out before
% trying these. 
%% Hypothesis Spaces

%% A small hypothesis space
function hypSpace = mathHypothesesSmall()
    hypSpace = [ evenOdd()
                 predicateBased( @(x)(x == round(sqrt(x)).^2),'squares')
                 multiples(3:10)
                 endingIn(1:9)
                 powers(2:10)
                 predicateBased(@(x)(x==x),'all')
                 compose(powers(2),explicitSet([37]),@union,' +')
                 compose(powers(2),explicitSet([32]),@setdiff,' -')
               ];
    fields = {'extension','name','size'};
    hypSpace = cell2struct(hypSpace,fields,2);
end

%% Tenenbaum's original hypothesis space with 34 mathematical and 5050 interval
function hypSpace = tenenbaumHypSpace()
    hypSpace = [    evenOdd()
                    predicateBased( @(x)(x == round(sqrt(x)).^2),'squares')
                    predicateBased( @(x)(x == round(x.^(1/3)).^3),'cubes')
                    predicateBased( @(x)(isprime(x)),'primes')
                    multiples(3:12)
                    powers(2:10)
                    endingIn(0:9)
                    allContiguousIntervals()
               ];
    
    fields = {'extension','name','size'};
    hypSpace = cell2struct(hypSpace,fields,2);
    
end    
%% Priors

% Prior on mathHypothesesSmall hypSpace, (a row vector)
function prior = mathPriorSmall(hypSpace)
    prior = [0.5 0.5 0.1*ones(1,28) 0.001 0.001];
    %{odd,even} = 0.5 ; {powers of 2 + 37,powers of 2 - 32} = 0.001; else=0.1
    assert(length(prior) == size(hypSpace,1));
    prior = prior ./ sum(prior);   
end

% Prior on tenenbaumHypSpace() Math hyps are weigthed 2/3 to 1/3 against
% interval hyps. Gamma(2,10) prior applied to interval length hyps. 
function prior = tenenbaumPrior(hypSpace)
     lambda = 2/3;
     math = (2/3)*ones(1,34);
     sizes = [hypSpace.size];
     sizes = sizes(35:end);     
     ints = exp(gammalogprob(struct('a', 2, 'b', 10), sizes));
     ints = (1/3)*ints;
     prior = [math ints];
     prior = prior ./ sum(prior);
end

%% Likelihoods

% Likelihood using the size principle: p(D|h)
% Returns row vector L, s.t. L(h) = p(D|h)
function L = likelihood(D,hypSpace)
    hypSpaceSize = size(hypSpace,1);
    n = length(D);
    lik = zeros(n,hypSpaceSize);
    for i=1:n
        lik(i,:) = inconcept(D(i),:) ./ [hypSpace.size]; 
    end
    L = prod(lik,1);
end

% Log Likelihood using size principle, log(p(D|h))
% Use to avoid numerical underflow.
function LL = logLikelihood(D,hypSpace)
    hypSpaceSize = size(hypSpace,1);
    n = length(D);
    llik = zeros(n,hypSpaceSize);
    for i=1:n
        %log(0) -> log(eps) to prevent NaN; note exp(log(eps)) = eps approx 0
        llik(i,:) = log((inconcept(D(i),:) ./ [hypSpace.size])+ eps); 
    end
    LL = sum(llik,1);
end

%% Posteriors

% Posterior Distribution, p(h|D)
function post = posterior(D,hypSpace)
    post = priorFn(hypSpace) .* likelihoodFn(D,hypSpace);
    post = post / sum(post);
end

% Posterior Distribution p(h|D) - uses log likelihood instead of just
% likelihood to help avoid numerical underflow. Returns p(h|D) not
% log(p(h|D)) but likelihoodFn needs to return log likelihood, not
% likelihood.
function post = posteriorLL(D,hypSpace)
    logLik = likelihoodFn(D,hypSpace);
    logPrior = log(priorFn(hypSpace));
    logNumerator = logLik + logPrior;
    post = exp(logNumerator);
    post = post / sum(post);
end
%% Predictive

% Posterior predictive distribution, p(x|D)
function pred = postPredictive(post)
    pred = inconcept * post(:); % pred(x) = sum_h inconcept(x,h) post(h)
end

% Prior Predictive Distribution:
% pred(i) is the prior predictive probability that integer i is in C
function pred = priorPredictive(hypSpace)
    prior = priorFn(hypSpace);
    cl = zeros(size(inconcept));
    for col=1:size(hypSpace,1)
        ext = hypSpace(col).extension;
        cl(ext,col) = inconcept(ext,col)./hypSpace(col).size;
    end
    % cl(x,h) = p(x|h) is the likelihood assigned to integer x by
    % hypothesis h by the size principle, (before any data has been seen).
    pred = cl(first:last,:)*prior'; 
end
    
%% Helper Functions

% Builds a binary table whose rows represent the possible data points in the
% range, (i.e. 1 - 100) - shifted so that the first is represented by index
% 1.The columns represent hypotheses, (i.e.indices into the hypSpace struct).
% Entry (d,h) = 1 iff data point d occurs in the extension of hypothesis h.
function inconcept = buildExtensionTable(hypSpace)
    hypSpaceSize = size(hypSpace,1);
    inconcept = zeros(last-first+1,hypSpaceSize);
    for h=1:hypSpaceSize
        hyp = hypSpace(h).extension; 
        inconcept(hyp,h) = 1;
    end
end
%% Display Functions

% Make a number of plots of the hypothesis space, prior,
% likelihood,posterior,and posterior predictive distributions. 
% Needs hypSpace and inconcept as global variables. 
function makePlots()        
    close all;
    data = [16,8,2,64];
    %data = [16, 23, 19, 20];
    %displayHypothesisSpace(inconcept,hypSpace);
    printPmtkFigure('joshHypSpace'); 
    
   
    plotPriorLikPost(16, hypSpace, priorFn, likelihoodFn,posteriorFn);
    printPmtkFigure('joshPriorLikPost16');
 
    
    plotPriorLikPost(data, hypSpace, priorFn, likelihoodFn,posteriorFn);
    printPmtkFigure('joshPriorLikPostAll');
    
    %{
    plotDistribution(data,hypSpace,likelihoodFn,1);
    printPmtkFigure('numbersLik');
    
    plotDistribution(data,hypSpace,posteriorFn,0);
    printPmtkFigure('numbersPost'); 
   
    plotPrior(hypSpace);
    printPmtkFigure('numbersPrior'); 
   %}
    
    visualizePredictive(inconcept,[16],hypSpace);
    %printPmtkFigure('josh-2-9');
    printPmtkFigure('joshPredictive16');
    
    %visualizePredictive(inconcept,data,hypSpace);
    %plotGamma();
end

% Display the top, 'howMany' hypotheses as determined by the specified
% posterior. 
function displayBestHyps(howMany,post)
    [H, idx] = sort(post,'descend');
    names = {hypSpace.name};
    fprintf('Top Posterior Hypotheses');
    fprintf('\n%1s %9s\n\n','Probability','Name');
    for i=1:1:howMany
        names = {hypSpace.name};
        fprintf('%1s\t\t\t %1s\n',num2str(H(i),'%6.5f'),cell2mat(names(idx(i))));
    end
end

% Visualize the hypothesis space. 
function displayHypothesisSpace(inconcept,hypSpace)
    fig = figure;
    ax = axes('Parent',fig,'XTick',1:size(hypSpace,1),'Position',[0.1,0.25,0.8,0.70]);
    axis([1,size(hypSpace,1),first-1,last+1]);
    hold on;
    imagesc(inconcept,'Parent',ax);
    colormap(gray);
    xticklabelRot({hypSpace.name}, 90, 8,-1);
    title('hypothesis space')
end


% Plot a labeled horizontal histogram of the current prior. 
function plotPrior(hypSpace)
    H = size(hypSpace,1);
    prior = priorFn(hypSpace);
    prior = prior(end:-1:1);
    names = {hypSpace.name};
    names = names(end:-1:1);
    fig = figure('Color',[1 1 1],'Position',[500 100 300,600]);
    axes('Parent',fig,'YTickLabel',names,'YTick',1:H,'Position',[0.4 0.12 0.50 0.8]);
    hold on;
    barh(prior);
    axis([0 1 0 H+1]);
    set(gca,'XTick',[0,0.5,1]);
    xlabel('p(h)');
end

%Plot either the likelihood or posterior distributions as histograms for
%successive data points. pdf should be likelihoodFn or posteriorFn and
%isLik=1 to print likelihood xlabel isLik=0 for posterior xlabel.
function plotDistribution(data,hypSpace,pdf,isLik)
   H = size(hypSpace,1);
   scrsz = get(0,'ScreenSize');
   fig = figure('Color',[1 1 1],'Position',[20 50 5*scrsz(3)/10 8*scrsz(4)/10]);
   n = length(data);
   height = 0.8; buffer = 0.03; y = 0.12; extraGap = 0.1;
   border = 0.1; width = (1-2*border - extraGap - buffer*(n-1))/n;
   for i=1:length(data)
       if(i==1)
           names = {hypSpace.name}; names = names(end:-1:1);
           ax = axes('Parent',fig,'YTickLabel',names,'YTick',1:H,'Position',[border+extraGap,y,width,height]);
       else
           ax = axes('Parent',fig,'YTick',[],'Position',[border+extraGap+(i-1)*(width+buffer),y,width,height]);
       end
      hold on;
       lik = pdf(data(1:i),hypSpace);
       lik = lik(end:-1:1);
       barh(lik,'Parent',ax);
       if(isLik)
           xlabel(['p(' num2str(data(1:i)) ' | h)']); 
       else
           xlabel(['p(h | ' num2str(data(1:i)) ' )']); 
       end
   end
end

  function plotPriorLikPost(data, hypSpace, priorFn, likFn, postFn)
    H = size(hypSpace,1);
     prior = priorFn(hypSpace);
    prior = prior(end:-1:1);
    
    scrsz = get(0,'ScreenSize');
    fig = figure('Color',[1 1 1],'Position',[20 50 5*scrsz(3)/10 8*scrsz(4)/10]);
    n = 3;
    height = 0.8; buffer = 0.03; y = 0.12; extraGap = 0.1;
    border = 0.1; width = (1-2*border - extraGap - buffer*(n-1))/n;
    
    names = {hypSpace.name}; names = names(end:-1:1);
    ax = axes('Parent',fig,'YTickLabel',names,'YTick',1:H,'Position',[border+extraGap,y,width,height]);   
    hold on;
    %barh(prior);
    barh(prior, 'Parent', ax);
    %axis([0 1 0 H+1]);
    %set(gca,'XTick',[0,0.5,1]);
    xlabel('prior');
    
    i = 2; ax =  axes('Parent',fig,'YTickLabel',names,'YTick',1:H,'Position',[border+extraGap+(i-1)*(width+buffer),y,width,height]);
    lik = likFn(data,hypSpace);
    lik = lik(end:-1:1);
    barh(lik,'Parent',ax);
    xlabel('lik');
     title(sprintf('data = %s', num2str(data))) 
     
    i = 3; ax =  axes('Parent',fig,'YTick',1:H,'YtickLabel',{},'Position',[border+extraGap+(i-1)*(width+buffer),y,width,height]);
    post = postFn(data,hypSpace);
    post = post(end:-1:1);
    barh(post,'Parent',ax);
    xlabel('post');
    
   
    
  end



% Visualize the posterior predictive distribution
function visualizePredictive(inconcept,data,hypSpace)
    
    post = posteriorFn(data,hypSpace);
    pred = postPredFn(post);
    scrsz = get(0,'ScreenSize');
    fig = figure('Color',[1 1 1],'Position',[20 50 9*scrsz(3)/10 8*scrsz(4)/10]);
    plotBar;
    probs = plotHyps;
    plotPost;
    function plotBar
        barAxLoc = [0.1,0.7,0.7,0.25];
        barAx = axes('Parent',fig,'XTick',first-1+4:4:last,'YTick',0:0.5:1,'Position',barAxLoc);
        hold on;
        bar(pred,'Parent',barAx);
        axis([first-1,last+1,0,1]);
    end
    function probs = plotHyps
        consistentHyps = 1:size(hypSpace,1);
        for i=1:length(data)
            consistentHyps = intersect(consistentHyps,find(inconcept(data(i),:) == 1));
        end
        names = {hypSpace.name};
        names = names(consistentHyps);
        [probs ndx] = sort(post(consistentHyps));
        names = names(ndx);
        consistentHyps = consistentHyps(ndx);
        hypAxLoc = [0.1,0.08,0.7,0.57];
        hypAx = axes('Parent',fig,'XTick',[],'YTick',1:length(names),'XColor',[1 1 1],'YTickLabel',names,'Position',hypAxLoc);
        hold on;
        for i=1:length(names)
            h = consistentHyps(i);
            hyp = hypSpace(h).extension;
            fplot(@(x)i,[first-1,last+1,1,length(names)+ 0.02],'-k');
            hold on;
            y = i*ones(length(hyp));
            plot(hyp,y,'.b','MarkerSize',20);
        end
    end
    function plotPost
        postAxLoc = [0.83,0.08,0.13,0.57];
        postAx = axes('Parent',fig,'XTick',0:0.5:1,'YTick',[],'Position',postAxLoc);
        xlabel(['p(h | ' num2str(data) ' )']); 
        hold on;
        plot(probs,1:length(probs),'-o','linewidth',3);
        axis([0,1,1,length(probs)]);     
    end
end




%% Hypothesis Building Functions

    %Returns two hypotheses: all even numbers in the range and all odd
    %numbers in the range. 
    function hypotheses = evenOdd()
       even = first+1:2:last;
       odd = first:2:last;
       hyps = [{even};{odd}];
       names = [{'even'};{'odd'}];
       sizes = [ {size(even,2)} ; {size(odd,2)}];
       hypotheses = [hyps names sizes];
    end


    % If range = 1:100 and ints = [3,9,10], then hypotheses =
    % [3,6,9,...,99]; [9,18,27,...,99];[10,20,30,...,100]
    function hypotheses = multiples(ints)
        n = length(ints);
        hyps = cell(n,1);
        names = cell(n,1);
        sizes = cell(n,1);
        for i=1:n
            m = ints(i);
            xmax = ceil(last/m);
            hyps{i,1} = intersect(first:last, m*(first:xmax));
            names{i,1} = sprintf('mult of %d', m);
            sizes{i,1} = size(hyps{i,1},2);
        end
        hypotheses = [hyps names sizes];    
    end
    
    % If range = 1:100 and ints = 1:3, then hypotheses = [1,11,21,...,91];
    % [2,22,32,...,92];[3,23,33,...,93]
    function hypotheses = endingIn(ints)
        fst = first - 1;
        lst = last - 10;
        n = length(ints);
        hyps =  cell(n,1); 
        names = cell(n,1);
        sizes = cell(n,1);
        for i=1:n
            m = ints(i);
            if m==0
                hyps{i,1} = (fst+10:10:lst+10) + m;
            else
                hyps{i,1} = (fst:10:lst) + m;
            end
            names{i,1} =  sprintf('ends in %d', m);
            sizes{i,1} = size(hyps{i,1},2);
        end  
        hypotheses = [hyps names sizes];
    end
    
    %If range = 1:100 and pows = 4:7, hypotheses = [4 16 64] ; [5 25];
    %[6:36]; [7;49]
    function hypotheses = powers(pows)
        n = length(pows);
        hyps = cell(n,1);
        names = cell(n,1);
        sizes = cell(n,1);
        for i=1:n;
            m = pows(i);
            xmax = ceil(log(last)/log(m)); 
            hyps{i,1} = intersect(first:last, m.^(first:xmax));
            names{i,1} = sprintf('powers of %d', m);
            sizes{i,1} = size(hyps{i,1},2);
        end
        hypotheses = [hyps names,sizes];
    end

    %Define an hypothesis by explicitly listing its members
    function hypothesis = explicitSet(set)
        hypothesis = [{set} {[' {' num2str(set) '}']} {size(set,2)}];
    end

    % Compose two hypothesis sets row-wise according to the specified set
    % operator, (i.e. @union, @setdiff, etc). If we specified @union,
    % and had hyp1(:,1) = {[1 2 3] ; [4 5 6]} and hyp2(:,1) = {[3 9 27];[4 44 444]}
    % this function would return hypotheses(:,1) =  {[1 2 3 9 27] ; 
    % [4 5 6 44 444]}. 'str' is displayed in the hypothesis name so use '+' for
    % 'union', '-' for setdiff, etc. 
    function hypotheses = compose(hyp1,hyp2,operator,str)
        n = size(hyp1,1);
        hyps = cell(n,1);
        names = cell(n,1);
        sizes = cell(n,1);
        for i=1:n
            hyps{i,1} = operator(cell2mat(hyp1(i,1))',cell2mat(hyp2(i,1))','rows')';
            names{i,1} = strcat(hyp1{i,2}, str, hyp2{i,2});
            sizes{i,1} = size(hyps{i,1},2);
        end
        hypotheses = [hyps names sizes];  
    end
    
   
    % Hypothesis = all numbers in the range satisfying the specified
    % predicate. So for example, if predicate = @isprime, then the hypothesis is
    % all prime numbers in the range. You can also define your own
    % predicates say  @(x)(x>50) or @(x)(x==x)
    function hypothesis = predicateBased(predicate,name)
        range = first:last;
        logicalNDX = predicate(range);
        size = sum(logicalNDX);
        hyp = range(logicalNDX);
        hypothesis = [{hyp} {name} {size}];
    end
    
    %Hypotheses = all contiguous intervals in the range so [1],
    %[1,2],...,[1,...,100],[2],[2,3],...,[2,...,100],... etc. 
    function hypotheses = allContiguousIntervals()
        i = 1;
        n = last*(last+1)/2;
        hyps = cell(n,1);
        names = cell(n,1);
        sizes = cell(n,1);
        for s = first:last
            for e=s:last
                hyps{i,1} = s:e;
                names{i,1} = sprintf('interval %d..%d', s, e);
                sizes{i,1} = size(hyps{i,1},2);
                i = i+1;
            end
        end
        hypotheses = [hyps names sizes];
    end
    
    %Hypotheses = all contiguous intervals in the range of the specified
    %lengths. Suppose lengths = 3:4, then we have
    %[1,2,3],[1,2,3,4],[2,3,4],[2,3,4,5],...,[97,98,99,100],[98,99,100]
    function hypotheses = contiguousIntervalsOflength(lengths)
        i = 1;
        n = sum(last - lengths + 1);
        hyps = cell(n,1);
        names = cell(n,1);
        sizes = cell(n,1);
        for len=1:length(lengths)
           for n=first:last
              m = n+len-1;
              if(m>last)
                  break
              end
              hyps{i,1} = n:m;
              names{i,1} = sprintf('interval %d..%d', n, m);
              sizes{i,1} = size(hyps{i,1},2);
              i = i+1;
           end
        end
        hypotheses = [hyps names sizes];    
    end

end

##### SOURCE END #####
--></body></html>