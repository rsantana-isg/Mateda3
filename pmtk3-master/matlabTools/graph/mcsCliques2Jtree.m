function jtree = mcsCliques2Jtree(clqs)
% input: clqs, a 1 x t cell array of nonempty cliques
%        of a chordal graph in the order produced by maxCardinalitySearch
% This is algo 4.8 of Cowell 1999 except
% we exploit the fact that the clqs were generated by mcs

% This file is from pmtk3.googlecode.com


% This is identical to ripCliques2Jtree
% but the name makes it clearer that it only works if the clq ordering
% was produced by mcs , since this guarantees there is an earlier
% clq k<i equal to C1 U .. C(i-1) 

t     = numel(clqs);
score = zeros(1, t); 
jtree = zeros(t, t);
for i=2:t;
  % Connect clq i to any previous clq k such that intersect(i,k) is nonemtpy
  clq1 = clqs{i};
  m1   = max(clq1);
  for k=1:i-1;
    clq2       = clqs{k};
    bits       = false(max(m1, max(clq2)), 1);
    bits(clq1) = true;
    score(k)   = sum(bits(clq2));
  end
  
  if 0
    % more readable version of above
    score2= zeros(1,t);
    for k=1:i-1;
      score2(k)=length(intersectPMTK(clqs{i}, clqs{k}));
    end;
    assert(isequal(score,score2))
  end
  
  if max(score)~=0
    % only add the edge if clique i IS connected to one of its
    % predecessors. if score is all zeros, then clique has no intersection
    % with any of its predecessors. Since the cliques are in RIP, it must
    % follow that we are no longer in the same connected component of
    % the graph.
    % if clique i has no intersection with any of the preceding cliques,
    % then the graph is disconnected, so the adjacency matrix will have
    % a zero row/column for this i, and we have a forest, not a j_tree.
    j = maxidx(score);
    jtree(i, j) = 1;
    jtree(j, i) = 1;
  end;
end;
